自动类型转换
* 若两种类型的字节数相同，且一种有符号，一种无符号，则转换成无符号类型
* 所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算
* char型和short型参与运算时，必须先转换成int型
宏定义 #define 和常量 const 的区别

类型和安全检查不同                        
编译器处理不同
存储方式不同
定义域不同
定义后能否取消

const 可以节省空间，避免不必要的内存分配
const提高了效率
宏替换只作替换
类中的常量

const 
* extern 修饰const 变量 可使该变量在多个文件间共享同一值（否则每个文件中const变量相互独立且都需初始化）
* 引用绑定到 const 对象上 ，就像绑定到其他对象上一样 ，称之为对常量的引用。 与普通引用不同的是,对常量的引 用不能被用作修改它所绑定的对象
* 用于声明引用的 const 都是底层 const
* auto 一般会忽略掉顶层 const，同时底层 const则会保留下来
引用
* 引用从来都作为其所指对象的同义词出现，只有用在 decltype 处是一 个例外

自 C++ 11 以来，auto 关键字用于两种情况：
* 声明变量时根据初始化表达式自动推断该变量的类型
* 声明函数时函数返回值的占位符

static 存储类
static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。
static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。
在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。

1.static 修饰类的成员变量
 1). 静态成员变量是先于类的对象而存在
 2). 这个类的所有对象共用一个静态成员
 3). 如果静态成员是公有的，那么可以直接通过类名调用
 4). 静态成员数据在声明时候类外初始化


2.static 修饰类的成员方法
 1). 静态成员函数是先于类的对象而存在
 2). 可用类名直接调用（公有）
 3). 在静态成员函数中没有this指针，所以不能使用非静态成员

const 修饰--常量 ---- const修饰的常量代替宏定义
修饰成员变量
const int data;
const 修饰的成员变量必须在构造方法的参数列表初始化（const static int pdata=10;除外）const 修饰的成员变量不能被修改
修饰成员方法
void showData()const{ }
const 修饰的成员函数中不能修改成员变量，不能调用非 const 修饰的函数


静态局部变量有以下特点：
该变量在全局数据区分配内存；
静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；
它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；

引用 vs 指针
* 不存在空引用。引用必须连接到一块合法的内存。
* 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象 
* 引用必须在创建时被初始化。指针可以在任何时间被初始化
* 引用本身不是一个对象 ，引用的定义所以不能定义引用的引用，不能定义指向引用的指针
* 存在对指针的引用

NULL vs nullptr vs 0
* NULL 在 C中是 void * 0; 在C++中是0
* C++是强类型语言，void *是不能隐式转换成其他指针类型
* NULL用在C++函数调用时，重载会默认为非指针类型

指向常量的指针 ( pointer to const) vs 常量指针 ( const pointer )

迭代器
* 因为 end 返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作
* const_iterator 和常量指针差不多，能读取但不能修改它所指的元素值。相反，iterator 的对象可读可写
* vector 对象或 string 对象是一个常量，只能使用 const_iterator